# SignalHandling
Signal : is an interrupt that is sent to a process by operating system indicating to perform an action immediately.
signal handling refers to the way that the operating system handles interrupts, which are generated by events such as user input or system errors. When a process receives a signal, the operating system interrupts the process and directs it to execute a signal handling routine, which is a function that is pre-defined by the operating system or that the process can define itself.
Both Unix and Windows operating systems have different signal handling mechanisms.
Unix Signal Handling :
Unix has a pretty straight forward mechanism which is using signal library which includes support for 31 different types of signals.These 31 signals include :
SIGHUP: Generated when a controlling terminal is closed or when a process receives a hang-up signal.

SIGINT: Generated when a user presses the interrupt key (usually Control-C) on the keyboard.

SIGQUIT: Generated when a user presses the quit key (usually Control-) on the keyboard.

SIGILL: Generated when a process attempts to execute an illegal instruction.

SIGTRAP: Generated by the debugger to signal a breakpoint or other debugging event.

SIGABRT: Generated when a process calls the abort() function.

SIGBUS: Generated when a process attempts to access memory that is not aligned to its required size or is otherwise invalid.

SIGFPE: Generated when a process attempts to perform an illegal floating-point operation, such as dividing by zero or taking the square root of a negative number.

SIGKILL: Generated when a process is killed using the kill command with the -9 option, or when the system sends a kill signal to a process that has become unresponsive.

SIGUSR1: A user-defined signal that can be generated by the application itself, for example, to communicate with other processes or to initiate some action.

SIGSEGV: Generated when a process attempts to access memory that is not allowed or when there is a segmentation fault.

SIGUSR2: Another user-defined signal that can be generated by the application.

SIGPIPE: Generated when a process tries to write to a pipe that has been closed by the reader.

SIGALRM: Generated when the timer set by the alarm() function expires.

SIGTERM: Generated when a process is terminated by the kill command without the -9 option.

SIGSTKFLT: Generated when a stack overflow occurs.

SIGCHLD: Generated when a child process terminates or stops.

SIGCONT: Generated when a stopped process is resumed.

SIGSTOP: Generated when a process is stopped using the kill command with the -STOP option.

SIGTSTP: Generated when a user presses the keyboard stop key (usually Control-Z).

SIGTTIN: Generated when a background process attempts to read from its controlling terminal.

SIGTTOU: Generated when a background process attempts to write to its controlling terminal.

SIGURG: Generated when urgent data arrives on a socket.

SIGXCPU: Generated when a process exceeds its CPU time limit.

SIGXFSZ: Generated when a process exceeds its file size limit.

SIGVTALRM: Generated when the timer set by the setitimer() function expires.

SIGPROF: Generated when the profiling timer set by the setitimer() function expires.

SIGWINCH: Generated when the window size changes.

SIGIO: Generated when I/O is possible on a file descriptor.

SIGPWR: Generated when there is a power failure.

SIGSYS: Generated when a process makes a bad system call.

Mechanism of handling signal:
1. Define a signal handler function: The first step is to define a function that will handle the signal. This function will be called whenever the signal is received by the process. The function should take a single integer argument, which is the signal number.

2. Set up the signal handler: To set up the signal handler, use the signal() system call, passing in the signal number and the address of the signal handler function. For example, to set up a handler for the SIGINT signal, you could use the following code:
```
void handle_sigint(int sig) {
    // handle the SIGINT signal
}

int main() {
    signal(SIGINT, handle_sigint);
    // rest of the program
    return 0;
}
```
3. Respond to the signal: When the signal is received by the process, the signal handler function will be called. Inside the signal handler, you can implement the desired response to the signal. This might involve cleaning up resources, printing an error message, or taking some other action.

4. Reset the signal handler: After the signal handler has been called, the signal will be reset to its default behavior. To prevent this, you can use the signal() system call again to set the signal handler back to your custom handler function.

It is important to note that some signals, such as SIGKILL and SIGSTOP, cannot be caught or ignored by the process. Additionally, signals can interrupt system calls and other blocking operations, so it is important to handle signals in a way that is safe and reliable.


Signal Handling in Windows:

Windows also have a signal library but unfortunately that header file has support for only common signals like SIGINT, SIGILL, SIGFPE,	SIGSEGV, SIGTERM, SIGBREAK, SIGABRT.
Their handling mechansim is same as the one present for unix operating systems.

Other Options:

1. Structured Exception Handling

Syntax: 
```
    // . . .
    __try {
        // guarded code
    }
    __except ( /* filter expression */ ) {
        // termination code
    }
    // . . .
```

Reference:https://learn.microsoft.com/en-us/cpp/cpp/structured-exception-handling-c-cpp?view=msvc-170

Example Code:
a . Divide by zero exception
```
#include <float.h>
#include <excpt.h>
#include <stdio.h>

void floating_point_exception_handler(unsigned int exception_code, EXCEPTION_POINTERS* exception_pointers) {
    printf("Floating point exception occurred!\n");
}

int main() {
    unsigned int fp_control_word = 0;
    _controlfp_s(&fp_control_word, _EM_INVALID, _MCW_EM);

    __try {
        float a = 1.0;
        float b = 0.0;
        float c = a / b;
    }
    __except (floating_point_exception_handler(GetExceptionCode(), GetExceptionInformation())) {
        // Handle the floating-point exception here
    }

    return 0;
}
```

b. Process exceeding its file size exception

```
#include <excpt.h>
#include <stdio.h>

void file_size_exception_handler(unsigned int exception_code, EXCEPTION_POINTERS* exception_pointers) {
    printf("Process exceeded its file size limit!\n");
}

int main() {
    __try {
        // Open a file and write data until the file size limit is exceeded
        FILE* file = fopen("test.txt", "w");
        if (file == NULL) {
            printf("Failed to open file\n");
            return 1;
        }
        int count = 0;
        while (1) {
            fprintf(file, "This is a test line %d\n", count);
            count++;
        }
        fclose(file);
    }
    __except (file_size_exception_handler(GetExceptionCode(), GetExceptionInformation())) {
        // Handle the file size exception here
    }

    return 0;
}
```
c.Stack Overflow Exception
```
#include <Windows.h>
#include <stdio.h>

int main() {
  __try {
    // Allocate a very large buffer on the stack to cause a stack overflow
    char buffer[1024 * 1024 * 1024]; // 1 GB
  }
  __except(GetExceptionCode() == EXCEPTION_STACK_OVERFLOW ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
    printf("Stack overflow exception caught\n");
  }
  return 0;
}
'''


The __try keyword is used for Structured Exception Handling (SEH) in C++ and Windows-specific versions of C. It is not part of the C standard, and may not be available on some platforms or compilers.Structured exception handling (SEH) is a Microsoft extension to C and C++ to handle certain exceptional code situations, such as hardware faults, gracefully
